/**
 * A mock JDBC driver delegating to a real JDBC driver,
 * with the possibility of simulating errors.<p>
 * The driver is a wrap around a real JDBC Driver.
 * The driver is controlled by a program, for example
 * "return a connection the first two times, fail on the third".
 * The returned connections themselves are wraps controlled
 * by a program, that can cause e.g.
 * {@link java.sql.Connection#createStatement()}
 * to fail on the second attempt. The returned statements are
 * again wraps around {@link java.sql.Statement} controlled by a program, etc.
 * <h2>Programs, Steps, and Wraps</h2>
 * A step is an entity that can modify the execution of a method call.
 * It is an implementation of the interface
 * {@link io.github.karstenspang.mockjdbc.Step}.
 * A program is a {@link java.util.function.Supplier} of steps.
 * The {@link io.github.karstenspang.mockjdbc.Program} class 
 * is a {@link java.util.function.Supplier}
 * based on a predefined list of steps to be returned in the specified order
 * when a step is needed.
 * <p>
 * A wrap is class implementing an interface in terms of another object
 * implementing the same interface (the wrapped object). It also holds a
 * program.
 * Each method in the wrap invokes the next step from the program, passing
 * a functional calling the corresponding method in the wrapped object.
 * For example
 * {@link io.github.karstenspang.mockjdbc.wrap.ConnectionWrap#createStatement()}:
 *<pre>
 *&#64;Override
 *public Statement createStatement()
 *    throws SQLException
 *{
 *    return stepSupplier.get().apply(()-&gt;wrapped.createStatement());
 *}
 *</pre>
 * It is up to {@code apply} to execute the method call.
 * Programs can be set on the
 * {@link io.github.karstenspang.mockjdbc.MockDriver},
 * or on wraps.
 * The program on
 * {@link io.github.karstenspang.mockjdbc.MockDriver} is used in
 * {@link io.github.karstenspang.mockjdbc.MockDriver#connect} only.
 * The logic is the same as above.
 * <p>
 * The following pre-defined {@link io.github.karstenspang.mockjdbc.Step} implementations exist:
 * <ul>
 *  <li>{@link io.github.karstenspang.mockjdbc.PassThruStep} passes the method call on to the
 *      wrapped driver and returns the result.</li>
 *  <li>{@link io.github.karstenspang.mockjdbc.ExceptionStep} throws an exception. The constructor
 *      takes the exception to throw as an argument. It must
 *      be an instance of {@link java.sql.SQLException}
 *      or {@link java.lang.RuntimeException}.</li>
 *  <li>{@link io.github.karstenspang.mockjdbc.WrapperStep} passes the method call on to the wrapped
 *      object, then wraps the result with a program, and returns the wrap.
 *      The constructors take a {@link io.github.karstenspang.mockjdbc.Wrapper} and a program as
 *      arguments.
 *      The wrapper is usually a function reference to the
 *      construtor of a wrap, e.g. {@link io.github.karstenspang.mockjdbc.wrap.ConnectionWrap}{@code ::new}.
 *      Two constructor variants exist. In the first, the program
 *      is an {@link java.lang.Iterable}{@code <}{@link io.github.karstenspang.mockjdbc.Step}{@code >}.
 *      This is usually a {@link java.util.List}, since you need the steps to be in
 *      a predictable sequence.
 *      In the other, the program is a
 *      {@link java.util.function.Supplier}{@code <}{@link io.github.karstenspang.mockjdbc.Step}{@code >},
 *      allowing you to write your own implementation doing something intelligent.</li>
 *  <li>{@link io.github.karstenspang.mockjdbc.ConstantStep} returns a constant value instead of
 *      executing the method.</li>
 *  <li>{@link io.github.karstenspang.mockjdbc.SupplierStep} returns the value of a function instead of
 *      executing the method.</li>
 *  <li>{@link io.github.karstenspang.mockjdbc.RunnableStep} executes some action instead of
 *      executing the method.</li>
 *  <li>{@link io.github.karstenspang.mockjdbc.FilterStep} executes the method and performs some
 *      transformation of the result. {@link io.github.karstenspang.mockjdbc.WrapperStep} is a
 *      specialized {@link io.github.karstenspang.mockjdbc.FilterStep}.</li>
 * </ul>
 * <h2>Autogenerated Wraps</h2>
 * Wraps around the interfaces in {@link java.sql} are included.
 * They reside in the
 * {@link io.github.karstenspang.mockjdbc.wrap} package.
 * <h2>Wrapping an object</h2>
 * There are two ways to wrap an object:
 * <ul>
 *  <li>Arrange for the method call creating the object to be subject
 *      to a {@link io.github.karstenspang.mockjdbc.WrapperStep}
 *      on the parent object, or the
 *      {@link io.github.karstenspang.mockjdbc.MockDriver}.</li>
 *  <li>Construct the wrap explicitely from an existing object and
 *      a program, using the appropriate wrap constructor.</li>
 * </ul>
 * <h2>Wrap or Wrapper</h2>
 * It has become custom to denote something which is wrapped around
 * something a "wrapper". This is not correct
 * English; strictly speaking such a thing is called a "wrap", and
 * a "wrapper" is a person or machine (or piece of software) that puts
 * the wrap on.
 * <p>
 * Since this software has both classes with the role "is a
 * wrap of something" and classes with the role "puts a wrap on
 * something", the former have "Wrap" as part of their name,
 * while the latter have "Wrapper" as part of their name.
 * <h2>Logging</h2>
 * In accordance with the standard for JDBC,
 * the driver uses {@link java.util.logging}.
 * All loggers are children of the logger named
 * {@code io.github.karstenspang.mockjdbc}.
 * The following is logged:
 * <ul>
 *  <li>When the driver is loaded, it logs its version with level {@link java.util.logging.Level#INFO}.</li>
 *  <li>When a step supplier is set in the driver, or a wrap is created, the step supplier
 *      is logged with level {@link java.util.logging.Level#FINE}.</li>
 *  <li>Before a step is applied, it is logged with level {@link java.util.logging.Level#FINEST}.
 *      If a result is returned from the step, it is logged as well.</li>
 * </ul>
 */
package io.github.karstenspang.mockjdbc;
