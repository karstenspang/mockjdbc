/**
 * A mock JDBC driver delegating to a real JDBC driver,
 * with the possibility of simulating errors.<br>
 * The driver is a wrap around a real JDBC Driver.
 * The driver is controlled by a program, for example
 * "return a connection the first two times, fail on the third".
 * The returned connections themselves are wraps controlled
 * by a program, that can cause e.g. {@link Connection#createStatement()}
 * to fail on the second attempt. The returned statements are
 * again wraps around {@link Statement} controlled by a program, etc.
 * <h3>Programs, Steps, and Wraps</h3>
 * A program is simply a list of steps to be run in the specified order
 * when a step is needed. Programs can be put on the {@link MockDriver},
 * or on wraps. A step is an implementation of the interface {@link Step}.
 * The following implementations are defined:
 * <ul>
 *  <li><code>PassThruStep</code> passes the method call on to the
 *      wrapped driver and returns the result.</li>
 *  <li><code>Excpetionstep</code> throws an exception. The constructor
 *      takes the exception to throw as an argument. It must
 *      be an instance of <code>SQLException</code>.</li>
 *  <li><code>WrapperStep</code> passes the method call on to the wrapped
 *      driver, then wraps the result with a program, and returns the wrap.
 *      The constructor takes a <code>Wrapper</code> and program as
 *      arguments.
 *      The wrapper is usually a function reference to the
 *      construtor of a wrap, e.g. <code>ConnectionWrap::new</code>.
 *      The program is an <code>Iterable&lt;Step&gt;</code>,
 *      usually a <code>List</code> or an array.</li>
 * </ul>
 * The {@link MockDriver} takes the next step from the program whenever
 * it needs to delegate connection creation to the wrapped class.
 * <h3>Autogenerated Wraps</h3>
 * Wraps around selected interfaces in {@link java.sql} are included.
 * All methods defined in the interface is implemented to call the
 * method wrapped object, after application of a {@link Step}, for
 * example {@link ConnectionWrap#createStatement()}:
 *<pre>
 *&#64;Override
 *public Statement createStatement()
 *    throws SQLException
 *{
 *    return steps.next().apply(()-&gt;wrapped.createStatement());
 *}
 *</pre>
 * In other words, <b>every</b> method call to a wraps causes the program
 * to be advanced to the next step.
 * They have a constructor that take an object to be wrapped and a
 * {@link Program}, thus matching the signature of {@link Wrapper},
 * like {@link ConnectionWrap#ConnectionWrap(Connection,Program)}.
 * <h3>Wrap or Wrapper</h3>
 * It has become custom to denote something which is wrapped around
 * something a "wrapper". This is not correct
 * English; strictly speaking such a thing is called a "wrap", and
 * a "wrapper" is a person or machine (or piece of software) that puts
 * the wrap on.
 * <p>
 * Since this software has both classes with the role "is a
 * wrap of something" and classes with the role "puts a wrap on
 * something", the former have "Wrap" as part of their name,
 * while the latter have "Wrapper" as part of their name.
 * <h3>Logging</h3>
 * In accordance with the standard for JDBC,
 * the driver uses {@link java.util.logging}.
 * All loggers are children of the logger named
 * {@code io.github.karstenspang.mockjdbc}.
 * The following is logged:
 * <ul>
 *  <li>When the driver is loaded, it logs its version with level <code>CONFIG</code>.</li>
 *  <li>When a program is set in the driver, or a mock is created, the program
 *      is logged with level <code>FINE</code>.</li>
 *  <li>When a step is applied, it is logged with level <code>FINEST</code>.</li>
 * </ul>
 */
package io.github.karstenspang.mockjdbc;

import java.sql.Connection;
import java.sql.Statement;
import java.util.List;